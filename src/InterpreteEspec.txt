Especificaciones intérprete:

Objetivo:
El objetivo es construir un intérprete con la suficiente capacidad para poder evaluar expresiones y comparaciones.

Decisiones de diseño:

1) Memoria para almacenar el valor de cada variable.

VARIABLES
    j: NUM;
    l:SEQ(NUM);
    booleano:LOG;

Nombre variable | Valor      |
------------------------------
j               |      4     |
------------------------------
l               |    [1,2,3] |
------------------------------
booleano        |     T      |
------------------------------

2) Evaluar operaciones
3) Declarar variables
4) Centinelas para ver si debemos insterpretar o no instrucciones (uno por cada bloque). Hay que actualizar
el centinela de cada bloque según la instrucción interpretada, la instruccion ruptura cambia a no hay que interpretar.
5) Interpretar llamada_a_funcion (en gramática)
6) Interpretar llamada_a_procedimiento (en gramática)
7) Interpretar condicional (en gramática)
8) Memoria para almacenar las funciones

Nombre función | Parámetros | Cuerpo
---------------|---------------------------------------------------------------------------------------------------------
vacia          |      seq   |   Su pseudocódigo sería:
               |            |       funcion vacia(seq){ // La secuencia será una cadena, debemos obtenerla de la memoria y
               |            |                           // de esta eliminamos los corchetes y separamos la cadena restante por
               |            |                           // comas, que serán los elementos de la secuencia.
               |            |                           // Si este array tiene longitud 0 será vacía, en otro caso no.
               |            |        String variable = memoria.get(seq);
               |            |        String[] elementos = eliminaCorchetesYseparaPorComas(variable);
               |            |        if(elementos.length==0) {
               |            |             return true;
               |            |         }else{
               |            |            return false;
               |            |         }
               |            |     }
-------------------------------------------------------------------------------------------------------------------------
ultima_posicion|    seq     |   Su pseudocódigo sería:
               |            |      funcion ultima_posicion(seq){ // La secuencia será una cadena, debemos rescatarla de la memoria
               |            |                                    // y obtener su valor. Esto lo haremos eliminando los corchetes de
               |            |                                    // la secuencia y creando un array donde guardaremos el resultado de
               |            |                                    // separar sus elementos por comas, nos quedarmos con el último elemento de este.
               |            |           String variable = memoria.get(seq);
               |            |           String[] elementos = eliminaCorchetesYseparaPorComas(variable);
               |            |           Devolver elementos[elementos.length-1];
               |            |       }
-------------------------------------------------------------------------------------------------------------------------
Para el resto de funciones se guardará en memoria su código en lenguaje P que será interpretado cada vez que se llame a la
función.

9) Interpretar asignacion (en gramática)




Gamática atribuida:
---------------------------
(1) memoria de las variables(global)

(8) memoria de las funciones(global) {misma memoria para funciones y procedimientos}
{Esta memoria tendrá incluidas las funciones del lenguaje P que son vacia y ultima_posicion}
{Se guardará el nombre de la función, sus parámetros y el cuerpo de la función}
---------------------------

programa: PROGRAMA variables subprogramas INSTRUCCIONES(instrucciones)?[hay que interpretar] EOF;

variables: VARIABLES (vars)*;

vars: varRecurs DOS_PUNTOS tipo PyC;

(3)

varRecurs: VAR COMA varRecurs {Declarar la variable VAR en la memoria de variables con valor null}
           |VAR {Declarar la variable VAR en la memoria de variables con valor null};

tipo: elemental | no_elemental;

elemental: NUM | LOG ;

no_elemental: SEQ_NUM | SEQ_LOG;

subprogramas:SUBPROGRAMAS (funcion | procedimiento)*;

funcion:FUNCION (fun)+ variables INSTRUCCIONES(instrucciones)* FFUNCION;
{Guardar en la memoria expresionF, que es el nombre de la función, junto con sus parámetros y su cuerpo}

fun: func | predicado;

expresionF: VAR (BB (VAR|NUMERO))*;

nombre_funcion: expresionF PARENTESIS_ABIERTO (expr2)* PARENTESIS_CERRADO;

func: nombre_funcion  retornoFuncion;

retornoFuncion: DEV PARENTESIS_ABIERTO expr2 PARENTESIS_CERRADO;

expr_booleana: T |F;

predicado: expresionF PARENTESIS_ABIERTO (expr2)* PARENTESIS_CERRADO DEV PARENTESIS_ABIERTO LOG VAR PARENTESIS_CERRADO;

expr2: NUM VAR COMA expr2  #NumVarComa
    | NUM VAR               #NumVar
    | no_elemental VAR COMA expr2 #SeqVarComa
    | no_elemental VAR             #SeqVar
    ;

procedimiento: PROCEDIMIENTO (proc)+ variables INSTRUCCIONES(instrucciones)? FPROCEDIMIENTO;

proc: expresionF PARENTESIS_ABIERTO exprProc PARENTESIS_CERRADO;

exprProc: no_elemental VAR COMA exprProc
        | no_elemental VAR
        | elemental VAR COMA exprProc
        | elemental VAR
        |;

instrucciones[c] dev d: d=asignacion[c] instrucciones
                | d=condicional[c] instrucciones
                | d=iteracion[c] instrucciones
                | d=ruptura[c] instrucciones
                | d=devolucion[c] instrucciones
                | d=llamada_a_funcion[c] instrucciones
                | d=llamada_a_procedimiento[c] instrucciones
                ;

(9)
asignacion[c]  dev d: v=asignacion_simple[c] | v=asignacion_multiple[c];  {Si (c es igual a hay que interpretar) entonces
                                                                             actualizar VAR en la memoria de variables con v
                                                                             d=c
                                                                           sino
                                                                             d=c
                                                                           fsi
                                                                           };

asignacion_simple[c] dev d: asignacion_binaria[c] | asignacion_logica[c] | asignacion_secuencia[c];


asignacion_binaria[c] dev d: VAR IGUAL ed=xpresion_binaria PyC; {Si el centinela es cierto se interpreta y se asigna el valor a VAR en memoria}

expresion_binaria[c] dev d: NUMERO #BinNum {Asignar al valor de NUMERO a la variable VAR}
    | VAR   #BinVar {Asignar al valor de VAR a la variable VAR}
    | NUMERO (operaciones)* #BinNumOp {Asignar al valor de NUMERO después de operaciones a la variable VAR}
    | VAR (operaciones)*    #BinVarOp {Asignar al valor de VAR después de operaciones a la variable VAR}
    | PARENTESIS_ABIERTO expresion_binaria PARENTESIS_CERRADO #BinParent
    | nombre_llamada_funcion #BinFun
    ;


asignacion_logica[c] dev d: VAR IGUAL expresion_logica PyC; {Si el centinela es cierto se interpreta y se asigna el valor a VAR en memoria}

expresion_logica: (NEGACION)?T #ExprLogTrue {Asignar el valor T a la variable VAR}
    | (NEGACION)?F              #ExprLogFalse {Asignar al valor F a la variable VAR}
    | (NEGACION)?VAR               #ExprLogVar {Asignar al valor VAR a la variable VAR}
    | (NEGACION)?nombre_llamada_funcion #ExprLogFun
    | (NEGACION)?llamada_a_procedimiento    #ExprLogProc
    ;

asignacion_secuencia[c] dev d: VAR IGUAL expresion_secuencia PyC ; {Si el centinela es cierto se interpreta y se asigna el valor a VAR en memoria}

expresion_secuencia[c] dev d: elemento_secuencia | secuencia_completa ;

elemento_secuencia[c]: VAR CORCHETE_ABIERTO (VAR | NUMERO)(operaciones)? CORCHETE_CERRADO;

secuencia_completa[c]: CORCHETE_ABIERTO (sec_binaria | sec_logica) CORCHETE_CERRADO;

sec_binaria: (NUMERO(operaciones)*|VAR(operaciones)*|llamada_a_funcion(operaciones)*|llamada_a_procedimiento) COMA sec_binaria  #SecBin// 2,5,4,6..
        | (NUMERO(operaciones)*|VAR(operaciones)*|llamada_a_funcion(operaciones)*|llamada_a_procedimiento) #SecBin2
        ;

sec_logica: expresion_logica COMA sec_logica #SecLog //T,T,F,F,T... #SecLog
        | expresion_logica #SecLog2
        ;


asignacion_multiple[c]: VAR (COMA VAR)+ IGUAL (expr5)+ PyC; {Si el centinela es cierto se interpreta y se asigna el valor a VAR en memoria}

expr5: expresion_binaria COMA expr5
    | expresion_binaria
    | expresion_logica COMA expr5
    | expresion_logica
    | expresion_secuencia COMA expr5
    | expresion_secuencia;

(2)
operaciones: SUMA (expresion_binaria)   #OpSuma {suma de var o numero más var o numero}
            |RESTA (expresion_binaria)  #OpResta {resta de var o numero más var o numero}
            |MULT (expresion_binaria)   #OpMult {multiplicacion de var o numero más var o numero}
            |DIV (expresion_binaria)    #OpDiv {división de var o numero más var o numero}
            ;
operaciones: SUMA (VAR|NUMERO)  {suma de var o numero más var o numero}
            |RESTA (VAR|NUMERO) {resta de var o numero más var o numero}
            |MULT (VAR|NUMERO) {multiplicacion de var o numero más var o numero}
            ;

(7)
condicional:(condicional_si)+;

condicional_si:SI v=condicion ENTONCES (instrucciones[f])* (bloque_opcional[g])? FSI; {Si (c es igual a hay que interpretar) entonces
                                                                                        si(v es igual a hay que interpretar) entonces
                                                                                            f = hay que interpretar
                                                                                            g = no hay que interpretar
                                                                                         sino
                                                                                            f=no hay que interpretar
                                                                                             g= hay que interpretar
                                                                                         fsi
                                                                                        fsi
                                                                                         };
{Si la condición es verdadera interpretaremos este bloque de instrucciones si no es verdadera interpretaremos el bloque_opcional}


condicion: PARENTESIS_ABIERTO cond1 cond2 (VAR|nombre_llamada_funcion|NUMERO) (concatena_operador_logico)* PARENTESIS_CERRADO;
{Obtener verdadero, falso o indefinido según el operador usado en la condición y sus variables. El caso indefinido ocurrirá
cuando alguna variable no tenga valor asignado}

concatena_operador_logico: (AND|OR) cond1 cond2 (VAR|nombre_llamada_funcion|NUMERO);

cond1: VAR CORCHETE_ABIERTO (VAR|NUMERO) (operaciones)? CORCHETE_CERRADO
      |VAR
      |NUMERO;



cond2: predicado | IGUALDAD | desigualdades ;

desigualdades: MAYORQ | MENORQ | MAY | MEN | DISTINTO;


bloque_opcional: SINO (instrucciones)*;
{Si la condición del bloque condicional_si es falsa interpretar este bloque}

iteracion: MIENTRAS condicion HACER (instrucciones)* FMIENTRAS; {Mientras condicion sea cierta realizar las instrucciones}

mostrar: MOSTRAR PARENTESIS_ABIERTO exprmostrar PARENTESIS_CERRADO PYC; {Mostrar por pantalla el valor de las variables indicadas}

exprmostrar: VAR
             | VAR COMA;

ruptura[c] dev d: RUPTURA PyC;  {Si (c es igual a hay que interpretar) entonces
                                    d = no hay que interpretar
                                  sino
                                    d=c
                                  fsi
                                  };
{Salir del bloque en el que nos encontramos hasta el bloque que engloba al actual sin ejecutar las instrucciones del bloque}

(5)
llamada_a_funcion: (expr5)+ IGUAL nombre_llamada_funcion PyC;
{Acceder a la memoria de la funcion en concreto, obtener su cuerpo y parámetros y después interpretar el cuerpo
de dicha función con los parámetros correspondientes}

nombre_llamada_funcion: expresionF PARENTESIS_ABIERTO (VAR|NUMERO) PARENTESIS_CERRADO;
(6)
llamada_a_procedimiento: expresionF PARENTESIS_ABIERTO (expr5) PARENTESIS_CERRADO PyC;
{Acceder a la memoria del procedimiento en concreto, obtener su cuerpo y parámetros y después interpretar el cuerpo de dicho procedimiento
con los parámetros correspondientes}

devolucion: DEV (NUMERO | expresion_logica)(COMA (NUMERO | expresion_logica))* PyC;
{Devolver el valor de la o las variables indicadas guardado en memoria}
