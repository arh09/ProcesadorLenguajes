OBJETIVO
--------
Construir un compiladorpara el lenguaje LF que traduzca a Java

DECISIONES DISEÑO
-----------------
La definición del compilador obliga a definir un criterio de corrección para decidir de forma precisa
cuándo una traducción es correcta.En la compilación de P, el criterio de corrección se basa
en el concepto de las variables e instrucciones independientes de cada ubicación (Programa principal y
Subprogramas).

GRAMATICA ATRIBUIDA
-------------------
almacen_definiciones1(global)-> programa principal
almacen_definiciones2(global)-> cada subprograma
boolean main(global)-->  distinguir el inicio de las instrucciones del main
integers--> lista para distinguir el tipo
booleans--> lista para distinguir el tipo
listint--> lista para distinguir el tipo
listbool--> lista para distinguir el tipo
cont--> distinguir entre variables globales y de cada subprograma

programa: {comienzo de la clase} PROGRAMA variables subprogramas INSTRUCCIONES instrucciones EOF{gener codigo de fin del main y de la clase};

variables: VARIABLES (vars)* {generar codigo declaración de vars};

vars: varRecurs DOS_PUNTOS tipo PyC {si cont==0 declarar varRecurs en almacen1 sino en almacen2}
{incluir varRecurs en la lista de su tipo};

varRecurs: VAR (COMA varRecurs)*;

tipo: elemental | no_elemental;

elemental: NUM | LOG ;

no_elemental: SEQ_NUM | SEQ_LOG;

subprogramas:{cont=1} SUBPROGRAMAS (funcion | procedimiento)* {cont=0};

funcion:{generar codigo comienzo de función} FUNCION fun variables INSTRUCCIONES instrucciones FFUNCION {limpiamos el almacen2};

fun: func | predicado;

expresionF: VAR (BB (VAR|NUMERO))*;

nombre_funcion: expresionF PARENTESIS_ABIERTO (expr2)* PARENTESIS_CERRADO;


//entrada--> secuencia posiblemente vacía , salida--> devuelve parámetros de salida
func: nombre_funcion  retornoFuncion;

retornoFuncion: DEV PARENTESIS_ABIERTO expr2 PARENTESIS_CERRADO;

expr_booleana: T |F;
//return valor lógico , entrada puede ser secuencia de números
predicado: expresionF PARENTESIS_ABIERTO (expr2)* PARENTESIS_CERRADO DEV PARENTESIS_ABIERTO LOG VAR PARENTESIS_CERRADO {booleans.add(VAR)};

expr2: NUM VAR COMA expr2 {declarar VAR} #NumVarComa
    | NUM VAR {declarar VAR}              #NumVar
    | no_elemental VAR COMA expr2 {declarar VAR} #SeqVarComa
    | no_elemental VAR  {declarar VAR}           #SeqVar
    ;

procedimiento:{generar codigo comienzo de procedimiento}  PROCEDIMIENTO proc variables INSTRUCCIONES instrucciones FPROCEDIMIENTO{limpiamos el almacen2};

proc: expresionF PARENTESIS_ABIERTO exprProc PARENTESIS_CERRADO;

exprProc: no_elemental VAR COMA exprProc
        | no_elemental VAR
        | elemental VAR COMA exprProc
        | elemental VAR
        |;

//Sin aserto ni función de avance (nivel 2)
instrucciones: {si main==true entonces comienzo del main} ((asignacion) | (condicional) | (iteracion)
| (ruptura) | (devolucion) | (llamada_a_funcion) | (llamada_a_procedimiento))* {main=false};

asignacion: asignacion_simple | asignacion_multiple {write ";"};

asignacion_simple: asignacion_binaria | asignacion_logica | asignacion_secuencia;
//VAR IGUAL CORCHETE_ABIERTO (expr4)+  CORCHETE_CERRADO PyC;


asignacion_binaria:{write "VAR ="} VAR IGUAL expresion_binaria PyC;

expresion_binaria: {write NUMERO} NUMERO #BinNum
    | {write VAR} VAR   #BinVar
    | {write NUMERO} NUMERO (operaciones)* #BinNumOp
    | {write VAR} VAR (operaciones)*    #BinVarOp
    | {write "("}PARENTESIS_ABIERTO expresion_binaria PARENTESIS_CERRADO {write )""}#BinParent
    | nombre_llamada_funcion #BinFun
    ;


asignacion_logica:{write "VAR ="}  VAR IGUAL expresion_logica PyC;

expresion_logica: {if NEGACION entonces write "false" sino write "true" }(NEGACION)?T #ExprLogTrue
    | {if NEGACION entonces write "true" sino write "false" }(NEGACION)?F              #ExprLogFalse
    | (NEGACION)?VAR               #ExprLogVar
    | (NEGACION)?nombre_llamada_funcion #ExprLogFun
    | (NEGACION)?llamada_a_procedimiento    #ExprLogProc
    ;

expresion_secuencia: elemento_secuencia | secuencia_completa ;

elemento_secuencia : {write "VAR["} VAR CORCHETE_ABIERTO expresion_binaria CORCHETE_CERRADO {write "]"};
secuencia_completa: {write "new Integer/Boolean []{"}CORCHETE_ABIERTO (sec_binaria | sec_logica)? CORCHETE_CERRADO {write "}"};

sec_binaria: {write VAR/NUMERO/llamada_a_funcion+","} (NUMERO(operaciones)*|VAR(operaciones)*|llamada_a_funcion(operaciones)*|llamada_a_procedimiento) COMA sec_binaria #SecBin// 2,5,4,6..
        | {write VAR/NUMERO/llamada_a_funcion} (NUMERO(operaciones)*|VAR(operaciones)*|llamada_a_funcion(operaciones)*|llamada_a_procedimiento) #SecBin2
        ;

sec_logica:{write expresion_logica+","} expresion_logica COMA sec_logica #SecLog //T,T,F,F,T... #SecLog
        | {write expresion_logica} expresion_logica #SecLog2
        ;

asignacion_secuencia:{write "VAR ="}  VAR IGUAL expresion_secuencia PyC ;

asignacion_multiple: VAR (CORCHETE_ABIERTO expresion_binaria CORCHETE_CERRADO)? (COMA VAR (CORCHETE_ABIERTO expresion_binaria CORCHETE_CERRADO)?)+ IGUAL (expr5)+ PyC;

expr5: expresion_binaria COMA expr5 //puede tener operaciones o no
    | expresion_binaria
    | expresion_logica COMA expr5
    | expresion_logica
    | expresion_secuencia COMA expr5
    | expresion_secuencia;

operaciones: {write "+"} SUMA (expresion_binaria)   #OpSuma
            | {write "-"} RESTA (expresion_binaria)  #OpResta
            | {write "*"} MULT (expresion_binaria)   #OpMult
            | {write "/"} DIV (expresion_binaria)    #OpDiv
            ;

//el bloque_opcional sería el SINO , puede que aparezca o no
condicional:{write "if" }SI condicion ENTONCES instrucciones (bloque_opcional)? FSI {write "}"} ;

condicion: {write "("} PARENTESIS_ABIERTO expr5 (desigualdades expr5)? (concatena_operador_logico)* PARENTESIS_CERRADO {write "){"} ;

//en caso de que haya un && o ||
concatena_operador_logico: {write and && / or ||}(AND|OR) expr5 (desigualdades expr5)?;

desigualdades: IGUALDAD | MAYORQ | MENORQ | MAY | MEN | DISTINTO {write desigualdad};


bloque_opcional:{write "}else{"}  SINO instrucciones;

//dentro del while puede haber if o no , entonces por eso (condicional)?
iteracion: {write "while"} MIENTRAS condicion HACER instrucciones FMIENTRAS {write "}"} ;

ruptura: RUPTURA PyC {write "break;"};

llamada_a_funcion: (expr5)+ IGUAL nombre_llamada_funcion PyC;

nombre_llamada_funcion:{write expresionF + "(" } expresionF PARENTESIS_ABIERTO (expr5)? PARENTESIS_CERRADO{write ")"};

llamada_a_procedimiento: {write expresionF + "(" }expresionF PARENTESIS_ABIERTO (expr5)? PARENTESIS_CERRADO PyC {write ");"} ;

devolucion: {write "return "} DEV expr5 PyC {write ";"};